# Database Design: PromptSculptor API (Prototype v1)

## 1. Database Design Summary

*   **Overview:** This document outlines the database schema for the PromptSculptor API prototype (v1). Given the initial focus on core, stateless endpoints (`/analyze`, `/remix`, `/create`) and the selection of **SQLite with SQLModel** for the prototype, the database requirements are minimal.
*   **Prototype Goal:** The primary goal for the database in v1 is to provide a basic logging mechanism for API requests and responses. This aids debugging and provides a foundation if more complex data persistence is needed later. No user data or core application state is stored in the database for this version.
*   **Technology:** **SQLite** database accessed via **SQLModel** in the Python/FastAPI backend.

## 2. Key Entities and Relationships

*   **Entities:**
    *   `ApiLog`: Represents a record of a single API call made to the service.
*   **Purpose:**
    *   `ApiLog`: To store details about each request received and the response generated by the `/analyze`, `/remix`, and `/create` endpoints. This includes timestamps, endpoint hit, request/response payloads, status code, and processing time.
*   **Relationships:**
    *   None. The `ApiLog` table is self-contained for the prototype.

## 3. ER Diagram (Optional but Recommended)

A formal ER diagram is overkill for a single table.

*   **Entity:** `ApiLog`
    *   **Attributes:** `id` (PK), `timestamp`, `endpoint`, `request_payload`, `response_payload`, `status_code`, `processing_time_ms`

## 4. SQLModel Schema (Python/SQLite)

This schema defines the structure for the `api_log` table using SQLModel, suitable for use with FastAPI and a SQLite database.

```python
# models/log.py (Example Location)
from sqlmodel import SQLModel, Field
from typing import Optional, Dict, Any
from datetime import datetime
import json # Or use Pydantic for validation before serialization

class ApiLogBase(SQLModel):
    timestamp: datetime = Field(default_factory=datetime.utcnow, index=True)
    endpoint: str = Field(index=True)
    request_payload: Optional[str] = Field(default=None) # Store as JSON string
    response_payload: Optional[str] = Field(default=None) # Store as JSON string
    status_code: int = Field(index=True)
    processing_time_ms: Optional[float] = Field(default=None)

class ApiLog(ApiLogBase, table=True):
    __tablename__ = "api_log" # Explicit table name
    id: Optional[int] = Field(default=None, primary_key=True)

# Note: For request/response_payload, storing as TEXT (implied by str type hint)
# is broadly compatible. If complex JSON querying within SQLite is needed later,
# consider SQLite's JSON type and appropriate SQLModel/SQLAlchemy configuration,
# potentially using a custom type decorator or the sqlalchemy-json type.
# For the prototype, storing serialized JSON as text is sufficient.
```

## 5. Prisma Schema (Node.js - Secondary)

This is an equivalent representation in Prisma schema syntax for potential future Node.js compatibility.

```prisma
// prisma/schema.prisma

datasource db {
  provider = "sqlite" // Matches prototype choice
  url      = "file:./promptsculptor_proto.db" // Example path
}

generator client {
  provider = "prisma-client-js"
}

model ApiLog {
  id                 Int       @id @default(autoincrement())
  timestamp          DateTime  @default(now())
  endpoint           String
  request_payload    String? // Storing JSON as String/TEXT
  response_payload   String? // Storing JSON as String/TEXT
  status_code        Int
  processing_time_ms Float?

  @@index([timestamp])
  @@index([endpoint])
  @@index([status_code])
  @@map("api_log") // Match table name
}

// Note: Prisma's native JSON type could be used if the target DB
// (even SQLite via Prisma) supports it well for the intended queries.
// Using String provides compatibility similar to the SQLModel approach above.
```

## 6. Design Rationale & Assumptions

*   **Minimalism:** The schema is intentionally minimal for the prototype, focusing only on logging. Features like user accounts, prompt history, saved styles, etc., are out of scope for v1 and thus have no corresponding tables.
*   **Stateless Core:** The core endpoints (`/analyze`, `/remix`, `/create`) are treated as stateless transformations, meaning their results are generated on-the-fly and not persisted in the database (only the *record* of the call is logged).
*   **SQLite Suitability:** SQLite is appropriate for this prototype due to its simplicity, file-based nature, and lack of complex relational needs or high concurrency requirements for v1 logging.
*   **Payload Storage:** Request and response payloads are stored as serialized JSON strings (TEXT) for simplicity and broad compatibility. Direct querying of JSON fields within the database is not a requirement for the prototype's logging function.
*   **Indexing:** Basic indexes are added to `timestamp`, `endpoint`, and `status_code` in the `ApiLog` table, anticipating potential filtering or analysis of logs, although performance is not a major concern for prototype-level logging.
*   **Future Scaling:** If the application evolves to require significant relational data, user management, or high write throughput, migrating from SQLite to a more robust database (e.g., PostgreSQL, MySQL) would be necessary. The use of an ORM (SQLModel/Prisma) simplifies such potential migrations.
